\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{algpseudocode}
\usepackage{mismath}
\usepackage{algorithm}
\usepackage[spanish]{babel}
\usepackage[letterpaper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}
\usepackage{amsmath}
\usepackage{alphabeta} 
\linespread{1.06}
\setlength{\parskip}{8pt plus2pt minus2pt}
\newcommand{\eat}[1]{}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}

\usepackage[official]{eurosym}
\usepackage{enumitem}
\setlist{nolistsep,noitemsep}
\usepackage[hidelinks]{hyperref}
\usepackage{cite}
\usepackage{lipsum}




\begin{document}

\begin{titlepage}
\begin{center}

% Top 
%\includegraphics[width=0.25\textwidth]{Univalle}~\\[1mm]


% Title
\HRule \\[0.4cm]
{ \LARGE 
  \textbf{Fundamentos de Analisis y Diseño de Algoritmos}\\[0.4cm]
  \emph{Mini-Proyecto}\\[0.4cm]
}
\HRule \\[1.5cm]



% Author
{ \large
  \textbf{Integrantes:} \\[0.1cm]
  KAROL MARIANA MAYORQUIN HERRERA - 1860682 3743\\[0.1cm]
  JENIFFER GUARIN ARISTIZABAL - 1860661 3743\\[0.1cm]
  EDINSON ORLANDO DORADO DORADO - 1941966 3743\\[0.1cm]
  SANTIAGO RAMIREZ OSPINA - 1841391 3743\\[0.1cm]
} 
\vfill
{ \large
    \textbf{Profesor:} \\[0.1cm]
    JESUS ALEXANDER ARANDA BUENO
}

\vfill

%\textsc{\Large Cyprus University of Technology}\\[0.4cm]
\textsc{\large Facultad de Ingeniería\\Escuela de Ingeniería de Sistemas \& Computación}\\[0.4cm]


% Bottom
{\large Marzo 22, 2022}
 
\end{center}
\end{titlepage}































%Fin de la portada
\section{Resumen y estructura del informe}
Lo primero que se presenta en el informe es el pseudocodigo que busca entre todas las posibilidades, una solucion optima, este algoritmo es recursivo, y usa fuerza bruta, o una técnica ciega. Este algoritmo será de utilidad al hacer el analisis de los 2 algoritmos siguientes. Un algoritmo que usa una tecnica voraz, y que al compararlo con el primer algoritmo vamos a poder ver cual es la relacion de soluciones optimas que encuentra el algorimto voraz comparado con el algoritmo que usa fuerza bruta. El último algoritmo que se muestra y analiza usa la técnica de programación dinámica, que en teoria, (en teoria debido a que esto se va a probar en el análisis de dicho algoritmo), encuentra la mejor solucion al problema, al igual que el primer algoritmo, pero de una forma mucho más eficiente.\newpage
















%Fin resumen
\section{Solución usando fuerza bruta}
Una forma segura de encontrar la solucion optima para algun problema, es procesar todas las soluciones. La forma que utliza el algoritmo mostrado abajo es comparar en cada llamado recursivo los dos caminos posibles que esa instancia del problema tiene. Esto lo hace, por supuesto, llamandose a si mismo con esas dos instancias, ambas, mas pequeñas que el problema orignial. Esto se hace hasta que se llega a un estado trivial, que es cuando el problema queda de un solo elemento en el array a y b (así mismo el array ab y ba quedan vacios).\newline

Como para solucionar cada instancia del problema, se crean dos mas, el numero de operaciones que se deben hacer son \textbf{$2^n$} aproximadamente. Lo cual tiene una complejidad \textbf{O($2^n$)}.\newline

Cabe recordar, que el objetivo con este primer algoritmo es solamente con fines de apoyar el análisis de los dos algormitmos siguientes.\newline



\begin{algorithmic}[1]
\Procedure{algoritmoCiego}{$n, a, b, ab, ba, counter, lineas, lineaActual$}
    \If{$n == 1$}
        \If{$lineaActual ==$ $ 'a'$}
            \State \textbf{return} counter + b[len(b) - n], lineas + [b[len(b) - n]]
        \Else
            \State \textbf{return} counter + b[len(b) - n], lineas + [b[len(b) - n]]
        \EndIf
    \Else
        \If{$lineaActual == $ $ 'a'$}
            \State \textbf{return} 
            \newline  min(\newline algoritmoCiego(n-1, a, b, ab, ba, counter + a[len(a) - n], lineas+[a[len(a) - n]], $'a'$), 
            \newline  algoritmoCiego(n-1, a, b, ab, ba, counter + ab[len(ab)-n+1] + a[len(a) - n], lineas + [a[len(a) - n]]+ [10*ab[len(ab)-n+1]], $'b'$))
        \Else
            \State \textbf{return} 
            \newline min(\newline algoritmoCiego(n-1, a, b, ab, ba, counter + ba[len(ba)-n+1] + b[len(b) - n], lineas + [b[len(b) - n]] + [10*ba[len(ba)-n+1]], $'a'$), 
            \newline  algoritmoCiego(n-1, a, b, ab, ba, counter  + b[len(b) - n], lineas + [b[len(b) - n]], $'b'$))
        \EndIf
    \EndIf
\EndProcedure
\end{algorithmic} 

\newpage
\includegraphics[width=0.9\textwidth]{graficos1y2.jpg}~\\[1mm]
\newpage
\includegraphics[width=0.9\textwidth]{graficos3y4.jpg}~\\[1mm]
\newpage
\includegraphics[width=\textwidth,height=25cm]{grafico5.jpg}~\\[1mm]


















%Fin Solucion por fuerza bruta
\section{Solución usando Programación Dinámica}
\subsection{Descripción de la idea}
Se hará uso de las tablas hash para indicar cada punto de ensamblaje con su respectiva posición. La llave estará conformada por: el carril (línea a ó línea b) y  la ubicación (posición del punto de ensamblaje). El contenido estará dado por: líneas (camino más óptimo que hay hasta un punto de ensamblaje) y counter (tiempo total del camino más óptimo que hay hasta un punto de ensamblaje). \newline

Se crea una función que indique por cual linea (a ó b) se va a empezar la producción (actividad 1), es decir, determina la línea que tiene menor valor en la posición 0. 

Se crea la función principal con los atributos: lineaInicial (indica en que linea se inicia la actividad 1), hash (tabla hash), a (linea a), b (linea b), ab (cambios de $"a"$ a $"b"$), ba (cambios de $"b"$ a $"a"$). Además se crea la variable estacion que indicará la posición del punto de ensamblaje que se está analizando, la cual se irá iterando dependiendo de los n puntos de ensamblaje. Se harán dos condiciones principales cuando(estación = 0) y cuando(estación $>$ 0). 
\newline
En la condición (estación = 0) se determina donde empieza la actividad 1; si (lineaInicial = a), se añade a la tabla hash $"b"$ en la posición 0 con infinito ($\infty$) y si (lineaInicial = b), se añade a la tabla hash $"a"$ en la posición 0 con infinito ($\infty$). 
\newline
En la segunda condición (estación $>$ 0), se crea la variable estacionDeAtras que será igual a estacion-1 y permitirá "mirar hacia atrás" e ir comparando en cada posición el menor valor que hay entre a y b. Para escoger el camino y guardarlo en la tabla hash se tiene en cuenta el valor del punto de ensamblaje siguiente en a y b, como también el valor de cada cambio (ab o ba).
\newline
En un primer if se analiza los posibles caminos optimos que hay si se toma los puntos de emsablaje que hay en $"a"$, entonces ubicados en un punto de ensamblaje en a miramos hacia atrás y comparamos el punto que esta justo antes del que se está analizando, si es menor que la suma del punto en $"b"$ de la estacionDeAtras y el cambio ba, si es asi, en la tabla hash se almacena la linea $"a"$ y el valor que tiene el punto de ensamblaje que está justo antes del punto que se está analizando en a.
\newline
En el segundo if de igual manera se analiza los posibles caminos optimos que hay si se toma los puntos de emsablaje que hay en $"b"$. Ubicados en un punto de ensamblaje en $"b"$ miramos hacia atrás y comparamos si tal punto es menor que la suma del punto en $"a"$ de la estacionDeAtras y el cambio ab, si es asi, en la tabla hash se almacena la linea $"b"$ y el valor que tiene el punto de ensamblaje que está justo antes del punto que se está analizando.















\subsection{Pseudocódigo}




\subsection{Análisis de complejidad}














\subsection{Parte (A)}
\subsubsection{Pseudocodigo}

\begin{algorithmic}[1]
\Procedure{funcion1}{$n$}
    \For{$i=2;$ $i \leq 5;$ $i = i * i$}
        \State \textbf{print} $("Hola Mundo")$
    \EndFor
    \For{$i=1;$ $i \leq n;$ $i = i * 5$}
        \State \textbf{print} $("Hola Mundo")$
    \EndFor
\EndProcedure
\end{algorithmic} 

\subsubsection{Analisis}
\subsubsection*{Análisis del  primer  for:}
El primer for se realiza 3 veces, \textit{i= 2, 4, 16}. El primer print se ejecuta la cantidad del for -1(se resta 1), es decir 2 veces.

\subsubsection*{Análisis del  segundo for:}
$n<5 \gets 1$
\newline
$n<25 \gets 2$
\newline
$n<125 \gets 3$
\newline
El segundo for se realiza  \textit{$\lceil log_5(n)\rceil + 1$} porque $i \leq n$,  cuando $5^i  = n$ entonces  $i=log_5(n)$, la función techo porque se hace una cantidad entera de operaciones y el +1 porque se suma la condición de parada.
El segundo print se ejecuta la misma cantidad del for -1(se resta 1), es decir  $\lceil log_5(n)\rceil$ veces. \\

$T(n) = 2 + \lceil log_5(n) \rceil  \to T(n) = \theta(1) + \theta(log(n))$ \\
Por lo tanto la complejidad es \\
\textbf{T(n) = $\theta$(log(n))}


\end{document}
